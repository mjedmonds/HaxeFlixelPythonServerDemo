# Generated by Haxe 4.1.2
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import inspect as python_lib_Inspect
import sys as python_lib_Sys
import functools as python_lib_Functools
import random as python_lib_Random
import re as python_lib_Re
import select as python_lib_Select
import time as python_lib_Time
import traceback as python_lib_Traceback
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import StringIO as python_lib_io_StringIO
from socket import socket as python_lib_socket_Socket


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __contains__(self, item):
        return item in self.__dict__
    def __getitem__(self, item):
        return self.__dict__[item]
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'



class Class: pass


class Date:
    _hx_class_name = "Date"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_statics = ["now", "makeLocal"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    @staticmethod
    def now():
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.now())
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except BaseException as _g:
            None
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))



class EReg:
    _hx_class_name = "EReg"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)



class Reflect:
    _hx_class_name = "Reflect"
    __slots__ = ()
    _hx_statics = ["field"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)


class Std:
    _hx_class_name = "Std"
    __slots__ = ()
    _hx_statics = ["is", "isOfType", "string", "parseInt"]

    @staticmethod
    def _hx_is(v,t):
        return Std.isOfType(v,t)

    @staticmethod
    def isOfType(v,t):
        if ((v is None) and ((t is None))):
            return False
        if (t is None):
            return False
        if (t == Dynamic):
            return (v is not None)
        isBool = isinstance(v,bool)
        if ((t == Bool) and isBool):
            return True
        if ((((not isBool) and (not (t == Bool))) and (t == Int)) and isinstance(v,int)):
            return True
        vIsFloat = isinstance(v,float)
        tmp = None
        tmp1 = None
        if (((not isBool) and vIsFloat) and (t == Int)):
            f = v
            tmp1 = (((f != Math.POSITIVE_INFINITY) and ((f != Math.NEGATIVE_INFINITY))) and (not python_lib_Math.isnan(f)))
        else:
            tmp1 = False
        if tmp1:
            tmp1 = None
            try:
                tmp1 = int(v)
            except BaseException as _g:
                None
                tmp1 = None
            tmp = (v == tmp1)
        else:
            tmp = False
        if ((tmp and ((v <= 2147483647))) and ((v >= -2147483648))):
            return True
        if (((not isBool) and (t == Float)) and isinstance(v,(float, int))):
            return True
        if (t == str):
            return isinstance(v,str)
        isEnumType = (t == Enum)
        if ((isEnumType and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_constructs")):
            return True
        if isEnumType:
            return False
        isClassType = (t == Class)
        if ((((isClassType and (not isinstance(v,Enum))) and python_lib_Inspect.isclass(v)) and hasattr(v,"_hx_class_name")) and (not hasattr(v,"_hx_constructs"))):
            return True
        if isClassType:
            return False
        tmp = None
        try:
            tmp = isinstance(v,t)
        except BaseException as _g:
            None
            tmp = False
        if tmp:
            return True
        if python_lib_Inspect.isclass(t):
            cls = t
            loop = None
            def _hx_local_1(intf):
                f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                if (f is not None):
                    _g = 0
                    while (_g < len(f)):
                        i = (f[_g] if _g >= 0 and _g < len(f) else None)
                        _g = (_g + 1)
                        if (i == cls):
                            return True
                        else:
                            l = loop(i)
                            if l:
                                return True
                    return False
                else:
                    return False
            loop = _hx_local_1
            currentClass = v.__class__
            result = False
            while (currentClass is not None):
                if loop(currentClass):
                    result = True
                    break
                currentClass = python_Boot.getSuperClass(currentClass)
            return result
        else:
            return False

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except BaseException as _g:
            None
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except BaseException as _g:
                    return None
            return None


class Float: pass


class Int: pass


class Bool: pass


class Dynamic: pass


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except BaseException as _g:
                None
                if Std.isOfType(haxe_Exception.caught(_g).unwrap(),StopIteration):
                    self.has = False
                    self.x = None
                else:
                    raise _g
            self.checked = True
        return self.has



class Sys:
    _hx_class_name = "Sys"
    __slots__ = ()
    _hx_statics = ["sleep", "systemName"]

    @staticmethod
    def sleep(seconds):
        python_lib_Time.sleep(seconds)

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise haxe_Exception.thrown("not supported platform")
            else:
                raise haxe_Exception.thrown("not supported platform")


class WebSocketHandler:
    _hx_class_name = "WebSocketHandler"
    __slots__ = ("_id", "_websocket")
    _hx_fields = ["_id", "_websocket"]
    _hx_methods = ["update", "onopen", "onerror", "onmessageString", "onmessageBytes", "onclose"]
    _hx_statics = ["_nextId"]

    def __init__(self,websocket):
        def _hx_local_2():
            _hx_local_0 = WebSocketHandler
            _hx_local_1 = _hx_local_0._nextId
            _hx_local_0._nextId = (_hx_local_1 + 1)
            return _hx_local_1
        self._id = _hx_local_2()
        self._websocket = websocket
        self._websocket.onopen = self.onopen
        self._websocket.onclose = self.onclose
        self._websocket.onerror = self.onerror
        self._websocket.onmessageBytes = self.onmessageBytes
        self._websocket.onmessageString = self.onmessageString

    def update(self):
        self._websocket.process()
        return (self._websocket.get_readyState() != haxe_net_ReadyState.Closed)

    def onopen(self):
        haxe_Log.trace((("" + Std.string(self._id)) + ":open"),_hx_AnonObject({'fileName': "WebSocketServerExample.hx", 'lineNumber': 32, 'className': "WebSocketHandler", 'methodName': "onopen"}))
        self._websocket.sendString("Hello from server")

    def onerror(self,message):
        haxe_Log.trace(((("" + Std.string(self._id)) + ":error: ") + ("null" if message is None else message)),_hx_AnonObject({'fileName': "WebSocketServerExample.hx", 'lineNumber': 38, 'className': "WebSocketHandler", 'methodName': "onerror"}))

    def onmessageString(self,message):
        haxe_Log.trace(((("" + Std.string(self._id)) + ":message: ") + ("null" if message is None else message)),_hx_AnonObject({'fileName': "WebSocketServerExample.hx", 'lineNumber': 43, 'className': "WebSocketHandler", 'methodName': "onmessageString"}))
        self._websocket.sendString(message)

    def onmessageBytes(self,message):
        haxe_Log.trace(((("" + Std.string(self._id)) + ":message bytes:") + HxOverrides.stringOrNull(message.toHex())),_hx_AnonObject({'fileName': "WebSocketServerExample.hx", 'lineNumber': 49, 'className': "WebSocketHandler", 'methodName': "onmessageBytes"}))
        self._websocket.sendBytes(message)

    def onclose(self):
        haxe_Log.trace((("" + Std.string(self._id)) + ":close"),_hx_AnonObject({'fileName': "WebSocketServerExample.hx", 'lineNumber': 55, 'className': "WebSocketHandler", 'methodName': "onclose"}))



class WebSocketServerExample:
    _hx_class_name = "WebSocketServerExample"
    __slots__ = ()
    _hx_statics = ["main"]

    @staticmethod
    def main():
        port = 8008
        host = "localhost"
        server = haxe_net_WebSocketServer.create(host,port,1,True)
        handlers = []
        haxe_Log.trace(((("listening to " + ("null" if host is None else host)) + " on port ") + Std.string(port)),_hx_AnonObject({'fileName': "WebSocketServerExample.hx", 'lineNumber': 67, 'className': "WebSocketServerExample", 'methodName': "main"}))
        while True:
            try:
                websocket = server.accept()
                if (websocket is not None):
                    x = WebSocketHandler(websocket)
                    handlers.append(x)
                toRemove = []
                _g = 0
                while (_g < len(handlers)):
                    handler = (handlers[_g] if _g >= 0 and _g < len(handlers) else None)
                    _g = (_g + 1)
                    if (not handler.update()):
                        toRemove.append(handler)
                while (len(toRemove) > 0):
                    python_internal_ArrayImpl.remove(handlers,(None if ((len(toRemove) == 0)) else toRemove.pop()))
            except BaseException as _g1:
                None
                Sys.sleep(0.1)


class haxe_Exception(Exception):
    _hx_class_name = "haxe.Exception"
    __slots__ = ("_hx___nativeStack", "_hx___skipStack", "_hx___nativeException", "_hx___previousException")
    _hx_fields = ["__nativeStack", "__skipStack", "__nativeException", "__previousException"]
    _hx_methods = ["unwrap", "get_native"]
    _hx_statics = ["caught", "thrown"]
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,message,previous = None,native = None):
        self._hx___previousException = None
        self._hx___nativeException = None
        self._hx___nativeStack = None
        self._hx___skipStack = 0
        super().__init__(message)
        self._hx___previousException = previous
        if ((native is not None) and Std.isOfType(native,BaseException)):
            self._hx___nativeException = native
            self._hx___nativeStack = haxe_NativeStackTrace.exceptionStack()
        else:
            self._hx___nativeException = self
            infos = python_lib_Traceback.extract_stack()
            if (len(infos) != 0):
                infos.pop()
            infos.reverse()
            self._hx___nativeStack = infos

    def unwrap(self):
        return self._hx___nativeException

    def get_native(self):
        return self._hx___nativeException

    @staticmethod
    def caught(value):
        if Std.isOfType(value,haxe_Exception):
            return value
        elif Std.isOfType(value,BaseException):
            return haxe_Exception(str(value),None,value)
        else:
            return haxe_ValueException(value,None,value)

    @staticmethod
    def thrown(value):
        if Std.isOfType(value,haxe_Exception):
            return value.get_native()
        elif Std.isOfType(value,BaseException):
            return value
        else:
            e = haxe_ValueException(value)
            e._hx___skipStack = (e._hx___skipStack + 1)
            return e



class haxe_Log:
    _hx_class_name = "haxe.Log"
    __slots__ = ()
    _hx_statics = ["formatOutput", "trace"]

    @staticmethod
    def formatOutput(v,infos):
        _hx_str = Std.string(v)
        if (infos is None):
            return _hx_str
        pstr = ((HxOverrides.stringOrNull(infos.fileName) + ":") + Std.string(infos.lineNumber))
        if (Reflect.field(infos,"customParams") is not None):
            _g = 0
            _g1 = Reflect.field(infos,"customParams")
            while (_g < len(_g1)):
                v = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                _hx_str = (("null" if _hx_str is None else _hx_str) + ((", " + Std.string(v))))
        return ((("null" if pstr is None else pstr) + ": ") + ("null" if _hx_str is None else _hx_str))

    @staticmethod
    def trace(v,infos = None):
        _hx_str = haxe_Log.formatOutput(v,infos)
        str1 = Std.string(_hx_str)
        python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))


class haxe_NativeStackTrace:
    _hx_class_name = "haxe.NativeStackTrace"
    __slots__ = ()
    _hx_statics = ["saveStack", "exceptionStack"]

    @staticmethod
    def saveStack(exception):
        pass

    @staticmethod
    def exceptionStack():
        exc = python_lib_Sys.exc_info()
        if (exc[2] is not None):
            infos = python_lib_Traceback.extract_tb(exc[2])
            infos.reverse()
            return infos
        else:
            return []


class haxe_ValueException(haxe_Exception):
    _hx_class_name = "haxe.ValueException"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["unwrap"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_Exception


    def __init__(self,value,previous = None,native = None):
        self.value = None
        super().__init__(Std.string(value),previous,native)
        self.value = value

    def unwrap(self):
        return self.value



class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["sub", "getString", "toString", "toHex"]
    _hx_statics = ["alloc", "ofString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def sub(self,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return haxe_io_Bytes(_hx_len,self.b[pos:(pos + _hx_len)])

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)

    def toHex(self):
        s_b = python_lib_io_StringIO()
        chars = []
        _hx_str = "0123456789abcdef"
        _g = 0
        _g1 = len(_hx_str)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            x = HxString.charCodeAt(_hx_str,i)
            chars.append(x)
        _g = 0
        _g1 = self.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = self.b[i]
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c >> 4))])))
            s_b.write("".join(map(chr,[python_internal_ArrayImpl._get(chars, (c & 15))])))
        return s_b.getvalue()

    @staticmethod
    def alloc(length):
        return haxe_io_Bytes(length,bytearray(length))

    @staticmethod
    def ofString(s,encoding = None):
        b = bytearray(s,"UTF-8")
        return haxe_io_Bytes(len(b),b)



class haxe_crypto_Base64:
    _hx_class_name = "haxe.crypto.Base64"
    __slots__ = ()
    _hx_statics = ["CHARS", "BYTES", "encode"]

    @staticmethod
    def encode(_hx_bytes,complement = None):
        if (complement is None):
            complement = True
        _hx_str = haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(_hx_bytes).toString()
        if complement:
            _g = HxOverrides.mod(_hx_bytes.length, 3)
            if (_g == 1):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "==")
            elif (_g == 2):
                _hx_str = (("null" if _hx_str is None else _hx_str) + "=")
            else:
                pass
        return _hx_str


class haxe_crypto_BaseCode:
    _hx_class_name = "haxe.crypto.BaseCode"
    __slots__ = ("base", "nbits")
    _hx_fields = ["base", "nbits"]
    _hx_methods = ["encodeBytes"]

    def __init__(self,base):
        _hx_len = base.length
        nbits = 1
        while (_hx_len > ((1 << nbits))):
            nbits = (nbits + 1)
        if ((nbits > 8) or ((_hx_len != ((1 << nbits))))):
            raise haxe_Exception.thrown("BaseCode : base length must be a power of two.")
        self.base = base
        self.nbits = nbits

    def encodeBytes(self,b):
        nbits = self.nbits
        base = self.base
        x = ((b.length * 8) / nbits)
        size = None
        try:
            size = int(x)
        except BaseException as _g:
            None
            size = None
        out = haxe_io_Bytes.alloc((size + ((0 if ((HxOverrides.mod((b.length * 8), nbits) == 0)) else 1))))
        buf = 0
        curbits = 0
        mask = (((1 << nbits)) - 1)
        pin = 0
        pout = 0
        while (pout < size):
            while (curbits < nbits):
                curbits = (curbits + 8)
                buf = (buf << 8)
                pos = pin
                pin = (pin + 1)
                buf = (buf | b.b[pos])
            curbits = (curbits - nbits)
            pos1 = pout
            pout = (pout + 1)
            v = base.b[((buf >> curbits) & mask)]
            out.b[pos1] = (v & 255)
        if (curbits > 0):
            pos = pout
            pout = (pout + 1)
            v = base.b[((buf << ((nbits - curbits))) & mask)]
            out.b[pos] = (v & 255)
        return out



class haxe_crypto_Sha1:
    _hx_class_name = "haxe.crypto.Sha1"
    __slots__ = ()
    _hx_methods = ["doEncode", "ft", "kt"]
    _hx_statics = ["make", "bytes2blks"]

    def __init__(self):
        pass

    def doEncode(self,x):
        w = list()
        a = 1732584193
        b = -271733879
        c = -1732584194
        d = 271733878
        e = -1009589776
        i = 0
        while (i < len(x)):
            olda = a
            oldb = b
            oldc = c
            oldd = d
            olde = e
            j = 0
            while (j < 80):
                if (j < 16):
                    python_internal_ArrayImpl._set(w, j, python_internal_ArrayImpl._get(x, (i + j)))
                else:
                    num = (((python_internal_ArrayImpl._get(w, (j - 3)) ^ python_internal_ArrayImpl._get(w, (j - 8))) ^ python_internal_ArrayImpl._get(w, (j - 14))) ^ python_internal_ArrayImpl._get(w, (j - 16)))
                    python_internal_ArrayImpl._set(w, j, ((num << 1) | (HxOverrides.rshift(num, 31))))
                t = (((((((a << 5) | (HxOverrides.rshift(a, 27)))) + self.ft(j,b,c,d)) + e) + (w[j] if j >= 0 and j < len(w) else None)) + self.kt(j))
                e = d
                d = c
                c = ((b << 30) | (HxOverrides.rshift(b, 2)))
                b = a
                a = t
                j = (j + 1)
            a = (a + olda)
            b = (b + oldb)
            c = (c + oldc)
            d = (d + oldd)
            e = (e + olde)
            i = (i + 16)
        return [a, b, c, d, e]

    def ft(self,t,b,c,d):
        if (t < 20):
            return ((b & c) | ((~b & d)))
        if (t < 40):
            return ((b ^ c) ^ d)
        if (t < 60):
            return (((b & c) | ((b & d))) | ((c & d)))
        return ((b ^ c) ^ d)

    def kt(self,t):
        if (t < 20):
            return 1518500249
        if (t < 40):
            return 1859775393
        if (t < 60):
            return -1894007588
        return -899497514

    @staticmethod
    def make(b):
        h = haxe_crypto_Sha1().doEncode(haxe_crypto_Sha1.bytes2blks(b))
        out = haxe_io_Bytes.alloc(20)
        p = 0
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[0] if 0 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[0] if 0 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[0] if 0 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[1] if 1 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[1] if 1 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[1] if 1 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[2] if 2 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[2] if 2 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[2] if 2 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[3] if 3 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[3] if 3 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[3] if 3 < len(h) else None) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (HxOverrides.rshift((h[4] if 4 < len(h) else None), 24) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 16) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = ((((h[4] if 4 < len(h) else None) >> 8) & 255) & 255)
        pos = p
        p = (p + 1)
        out.b[pos] = (((h[4] if 4 < len(h) else None) & 255) & 255)
        return out

    @staticmethod
    def bytes2blks(b):
        nblk = ((((b.length + 8) >> 6)) + 1)
        blks = list()
        _g = 0
        _g1 = (nblk * 16)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            python_internal_ArrayImpl._set(blks, i, 0)
        _g = 0
        _g1 = b.length
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            p = (i >> 2)
            python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((b.b[i] << ((24 - ((((i & 3)) << 3))))))))
        i = b.length
        p = (i >> 2)
        python_internal_ArrayImpl._set(blks, p, ((blks[p] if p >= 0 and p < len(blks) else None) | ((128 << ((24 - ((((i & 3)) << 3))))))))
        python_internal_ArrayImpl._set(blks, ((nblk * 16) - 1), (b.length * 8))
        return blks


class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
    _hx_constructs = ["UTF8", "RawNative"]
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"
    _hx_constructs = ["Blocked", "Overflow", "OutsideBounds", "Custom"]

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    __slots__ = ()
    _hx_methods = ["readByte", "readBytes"]

    def readByte(self):
        raise haxe_Exception.thrown("Not implemented")

    def readBytes(self,s,pos,_hx_len):
        k = _hx_len
        b = s.b
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        try:
            while (k > 0):
                b[pos] = self.readByte()
                pos = (pos + 1)
                k = (k - 1)
        except BaseException as _g:
            None
            if (not Std.isOfType(haxe_Exception.caught(_g).unwrap(),haxe_io_Eof)):
                raise _g
        return (_hx_len - k)



class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    __slots__ = ()
    _hx_methods = ["writeByte", "writeBytes", "flush", "write"]

    def writeByte(self,c):
        raise haxe_Exception.thrown("Not implemented")

    def writeBytes(self,s,pos,_hx_len):
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > s.length))):
            raise haxe_Exception.thrown(haxe_io_Error.OutsideBounds)
        b = s.b
        k = _hx_len
        while (k > 0):
            self.writeByte(b[pos])
            pos = (pos + 1)
            k = (k - 1)
        return _hx_len

    def flush(self):
        pass

    def write(self,s):
        l = s.length
        p = 0
        while (l > 0):
            k = self.writeBytes(s,p,l)
            if (k == 0):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            p = (p + k)
            l = (l - k)



class haxe_iterators_ArrayIterator:
    _hx_class_name = "haxe.iterators.ArrayIterator"
    __slots__ = ("array", "current")
    _hx_fields = ["array", "current"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return python_internal_ArrayImpl._get(self.array, _hx_local_2())
        return _hx_local_3()



class haxe_iterators_ArrayKeyValueIterator:
    _hx_class_name = "haxe.iterators.ArrayKeyValueIterator"
    __slots__ = ("current", "array")
    _hx_fields = ["current", "array"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,array):
        self.current = 0
        self.array = array

    def hasNext(self):
        return (self.current < len(self.array))

    def next(self):
        def _hx_local_3():
            def _hx_local_2():
                _hx_local_0 = self
                _hx_local_1 = _hx_local_0.current
                _hx_local_0.current = (_hx_local_1 + 1)
                return _hx_local_1
            return _hx_AnonObject({'value': python_internal_ArrayImpl._get(self.array, self.current), 'key': _hx_local_2()})
        return _hx_local_3()



class haxe_net_Socket2:
    _hx_class_name = "haxe.net.Socket2"
    _hx_fields = ["host", "port", "debug"]
    _hx_methods = ["close", "process", "onconnect", "onclose", "onerror", "ondata", "send"]
    _hx_statics = ["create", "createFromExistingSocket"]

    def __init__(self,host,port,debug = None):
        if (debug is None):
            debug = False
        self.host = host
        self.port = port
        self.debug = debug

    def close(self):
        pass

    def process(self):
        pass

    def onconnect(self):
        pass

    def onclose(self):
        pass

    def onerror(self):
        pass

    def ondata(self,data):
        pass

    def send(self,data):
        pass

    @staticmethod
    def create(host,port,secure = None,debug = None):
        if (secure is None):
            secure = False
        if (debug is None):
            debug = False
        return haxe_net_impl_SocketSys.create(host,port,secure,debug)

    @staticmethod
    def createFromExistingSocket(socket,debug = None):
        if (debug is None):
            debug = False
        return haxe_net_impl_SocketSys.createFromExistingSocket(socket,debug)


class haxe_net_ReadyState(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.net.ReadyState"
    _hx_constructs = ["Connecting", "Open", "Closing", "Closed"]
haxe_net_ReadyState.Connecting = haxe_net_ReadyState("Connecting", 0, ())
haxe_net_ReadyState.Open = haxe_net_ReadyState("Open", 1, ())
haxe_net_ReadyState.Closing = haxe_net_ReadyState("Closing", 2, ())
haxe_net_ReadyState.Closed = haxe_net_ReadyState("Closed", 3, ())


class haxe_net_WebSocket:
    _hx_class_name = "haxe.net.WebSocket"
    _hx_methods = ["process", "sendString", "sendBytes", "close", "get_readyState", "onopen", "onerror", "onmessageString", "onmessageBytes", "onclose"]
    _hx_statics = ["create", "createFromAcceptedSocket", "defer"]

    def __init__(self):
        pass

    def process(self):
        pass

    def sendString(self,message):
        pass

    def sendBytes(self,message):
        pass

    def close(self):
        pass

    def get_readyState(self):
        raise haxe_Exception.thrown("Not implemented")

    def onopen(self):
        pass

    def onerror(self,message):
        pass

    def onmessageString(self,message):
        pass

    def onmessageBytes(self,message):
        pass

    def onclose(self):
        pass

    @staticmethod
    def create(url,protocols = None,origin = None,debug = None):
        if (debug is None):
            debug = False
        return haxe_net_impl_WebSocketGeneric.create(url,protocols,origin,"wskey",debug)

    @staticmethod
    def createFromAcceptedSocket(socket,alreadyRecieved = None,debug = None):
        if (alreadyRecieved is None):
            alreadyRecieved = ""
        if (debug is None):
            debug = False
        return haxe_net_impl_WebSocketGeneric.createFromAcceptedSocket(socket,alreadyRecieved,debug)

    @staticmethod
    def defer(callback):
        callback()



class haxe_net_WebSocketServer:
    _hx_class_name = "haxe.net.WebSocketServer"
    __slots__ = ("_isDebug", "_listenSocket")
    _hx_fields = ["_isDebug", "_listenSocket"]
    _hx_methods = ["accept"]
    _hx_statics = ["create"]

    def __init__(self,host,port,maxConnections,isDebug):
        self._isDebug = isDebug
        self._listenSocket = sys_net_Socket()
        self._listenSocket.setBlocking(False)
        self._listenSocket.bind(sys_net_Host(host),port)
        self._listenSocket.listen(maxConnections)

    def accept(self):
        try:
            socket = self._listenSocket.accept()
            return haxe_net_WebSocket.createFromAcceptedSocket(haxe_net_Socket2.createFromExistingSocket(socket,self._isDebug),"",self._isDebug)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            if ((e == "Blocking") or ((e == haxe_io_Error.Blocked))):
                return None
            else:
                raise haxe_Exception.thrown(e)

    @staticmethod
    def create(host,port,maxConnections,isDebug):
        return haxe_net_WebSocketServer(host,port,maxConnections,isDebug)



class haxe_net_impl_BytesRW:
    _hx_class_name = "haxe.net.impl.BytesRW"
    __slots__ = ("available", "currentOffset", "currentData", "chunks")
    _hx_fields = ["available", "currentOffset", "currentData", "chunks"]
    _hx_methods = ["writeByte", "writeShort", "writeInt", "writeBytes", "readAllAvailableBytes", "readBytes", "readUnsignedShort", "readUnsignedInt", "readByte"]

    def __init__(self):
        self.chunks = []
        self.currentData = None
        self.currentOffset = 0
        self.available = 0

    def writeByte(self,v):
        b = haxe_io_Bytes.alloc(1)
        b.b[0] = (v & 255)
        self.writeBytes(b)

    def writeShort(self,v):
        b = haxe_io_Bytes.alloc(2)
        b.b[0] = (((v >> 8) & 255) & 255)
        b.b[1] = ((v & 255) & 255)
        self.writeBytes(b)

    def writeInt(self,v):
        b = haxe_io_Bytes.alloc(4)
        b.b[0] = (((v >> 24) & 255) & 255)
        b.b[1] = (((v >> 16) & 255) & 255)
        b.b[2] = (((v >> 8) & 255) & 255)
        b.b[3] = ((v & 255) & 255)
        self.writeBytes(b)

    def writeBytes(self,data):
        _this = self.chunks
        _this.append(data)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.available
        _hx_local_0.available = (_hx_local_1 + data.length)
        _hx_local_0.available

    def readAllAvailableBytes(self):
        return self.readBytes(self.available)

    def readBytes(self,count):
        b = self.available
        x = (count if (python_lib_Math.isnan(count)) else (b if (python_lib_Math.isnan(b)) else min(count,b)))
        count2 = None
        try:
            count2 = int(x)
        except BaseException as _g:
            None
            count2 = None
        out = haxe_io_Bytes.alloc(count2)
        _g = 0
        _g1 = count2
        while (_g < _g1):
            n = _g
            _g = (_g + 1)
            v = self.readByte()
            out.b[n] = (v & 255)
        return out

    def readUnsignedShort(self):
        h = self.readByte()
        l = self.readByte()
        return ((h << 8) | l)

    def readUnsignedInt(self):
        v3 = self.readByte()
        v2 = self.readByte()
        v1 = self.readByte()
        v0 = self.readByte()
        return ((((v3 << 24) | ((v2 << 16))) | ((v1 << 8))) | v0)

    def readByte(self):
        if (self.available <= 0):
            raise haxe_Exception.thrown("Not bytes available")
        while ((self.currentData is None) or ((self.currentOffset >= self.currentData.length))):
            self.currentOffset = 0
            _this = self.chunks
            self.currentData = (None if ((len(_this) == 0)) else _this.pop(0))
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.available
        _hx_local_0.available = (_hx_local_1 - 1)
        _hx_local_1
        pos = self.currentOffset
        self.currentOffset = (self.currentOffset + 1)
        return self.currentData.b[pos]



class haxe_net_impl_SocketSys(haxe_net_Socket2):
    _hx_class_name = "haxe.net.impl.SocketSys"
    _hx_fields = ["impl", "sendConnect", "sendError", "wasCloseSent", "secure", "isClosed"]
    _hx_methods = ["initialize", "close", "process", "onconnect", "onclose", "onerror", "ondata", "send"]
    _hx_statics = ["create", "createFromExistingSocket"]
    _hx_interfaces = []
    _hx_super = haxe_net_Socket2


    def __init__(self,host,port,debug = None):
        if (debug is None):
            debug = False
        self.secure = None
        self.impl = None
        self.isClosed = False
        self.wasCloseSent = False
        self.sendError = False
        self.sendConnect = False
        super().__init__(host,port,debug)

    def initialize(self,secure):
        self.secure = secure
        impl = None
        if secure:
            self.impl = sys_ssl_Socket()
        else:
            self.impl = sys_net_Socket()
        try:
            self.impl.connect(sys_net_Host(self.host),self.port)
            self.impl.setBlocking(False)
            self.sendConnect = True
            if self.debug:
                haxe_Log.trace("socket.connected!",_hx_AnonObject({'fileName': "haxe/net/impl/SocketSys.hx", 'lineNumber': 37, 'className': "haxe.net.impl.SocketSys", 'methodName': "initialize"}))
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            self.sendError = True
            if self.debug:
                haxe_Log.trace(("socket.error! " + Std.string(e)),_hx_AnonObject({'fileName': "haxe/net/impl/SocketSys.hx", 'lineNumber': 40, 'className': "haxe.net.impl.SocketSys", 'methodName': "initialize"}))
        return self

    def close(self):
        self.impl.close()
        if (not self.wasCloseSent):
            self.wasCloseSent = True
            if self.debug:
                haxe_Log.trace("socket.onclose!",_hx_AnonObject({'fileName': "haxe/net/impl/SocketSys.hx", 'lineNumber': 63, 'className': "haxe.net.impl.SocketSys", 'methodName': "close"}))
            self.onclose()

    def process(self):
        if self.sendConnect:
            if self.debug:
                haxe_Log.trace("socket.onconnect!",_hx_AnonObject({'fileName': "haxe/net/impl/SocketSys.hx", 'lineNumber': 70, 'className': "haxe.net.impl.SocketSys", 'methodName': "process"}))
            self.sendConnect = False
            self.onconnect()
        if self.sendError:
            if self.debug:
                haxe_Log.trace("socket.onerror!",_hx_AnonObject({'fileName': "haxe/net/impl/SocketSys.hx", 'lineNumber': 76, 'className': "haxe.net.impl.SocketSys", 'methodName': "process"}))
            self.sendError = False
            self.onerror()
        needClose = False
        result = None
        try:
            result = sys_net_Socket.select([self.impl],[self.impl],[self.impl],0.4)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            if self.debug:
                haxe_Log.trace(("closing socket because of " + Std.string(e)),_hx_AnonObject({'fileName': "haxe/net/impl/SocketSys.hx", 'lineNumber': 87, 'className': "haxe.net.impl.SocketSys", 'methodName': "process"}))
            needClose = True
        if ((result is not None) and (not needClose)):
            if (len(result.read) > 0):
                out = haxe_net_impl_BytesRW()
                try:
                    input = self.impl.input
                    while True:
                        data = haxe_io_Bytes.alloc(1024)
                        readed = input.readBytes(data,0,data.length)
                        if (readed <= 0):
                            break
                        out.writeBytes(data.sub(0,readed))
                except BaseException as _g:
                    None
                    e = haxe_Exception.caught(_g).unwrap()
                    needClose = (not (((e == "Blocking") or ((Std.isOfType(e,haxe_io_Error) and ((e.index == 0)))))))
                    if (needClose and self.debug):
                        haxe_Log.trace(("closing socket because of " + Std.string(e)),_hx_AnonObject({'fileName': "haxe/net/impl/SocketSys.hx", 'lineNumber': 104, 'className': "haxe.net.impl.SocketSys", 'methodName': "process"}))
                self.ondata(out.readAllAvailableBytes())
        if needClose:
            self.close()

    def onconnect(self):
        pass

    def onclose(self):
        pass

    def onerror(self):
        pass

    def ondata(self,data):
        pass

    def send(self,data):
        output = self.impl.output
        output.write(data)
        output.flush()

    @staticmethod
    def create(host,port,secure,debug = None):
        if (debug is None):
            debug = False
        return haxe_net_impl_SocketSys(host,port,debug).initialize(secure)

    @staticmethod
    def createFromExistingSocket(socket,debug = None):
        if (debug is None):
            debug = False
        socketSys = haxe_net_impl_SocketSys(socket.host().host.host,socket.host().port,debug)
        socket.setBlocking(False)
        socketSys.impl = socket
        socketSys.secure = False
        return socketSys



class haxe_net_impl_WebSocketGeneric(haxe_net_WebSocket):
    _hx_class_name = "haxe.net.impl.WebSocketGeneric"
    __slots__ = ("socket", "origin", "scheme", "key", "host", "port", "path", "secure", "protocols", "state", "debug", "needHandleData", "socketData", "isFinal", "isMasked", "opcode", "frameIsBinary", "partialLength", "length", "mask", "httpHeader", "lastPong", "payload")
    _hx_fields = ["socket", "origin", "scheme", "key", "host", "port", "path", "secure", "protocols", "state", "debug", "needHandleData", "socketData", "isFinal", "isMasked", "opcode", "frameIsBinary", "partialLength", "length", "mask", "httpHeader", "lastPong", "payload"]
    _hx_methods = ["initialize", "commonInitialize", "process", "_debug", "writeBytes", "handleData", "setClosed", "ping", "isHttpHeaderRead", "readHttpHeader", "prepareServerHandshake", "prepareHttp400", "prepareClientHandshake", "close", "sendFrame", "get_readyState", "sendString", "sendBytes", "prepareFrame"]
    _hx_statics = ["create", "createFromAcceptedSocket", "generateMask", "applyMask"]
    _hx_interfaces = []
    _hx_super = haxe_net_WebSocket


    def __init__(self):
        self.mask = None
        self.length = None
        self.partialLength = None
        self.frameIsBinary = None
        self.opcode = None
        self.isMasked = None
        self.isFinal = None
        self.socketData = None
        self.socket = None
        self.payload = None
        self.lastPong = None
        self.httpHeader = ""
        self.needHandleData = False
        self.debug = True
        self.state = haxe_net_impl_State.Handshake
        self.protocols = []
        self.secure = False
        self.path = "/"
        self.port = 80
        self.host = "127.0.0.1"
        self.key = "wskey"
        self.scheme = "ws"
        self.origin = "http://127.0.0.1/"
        super().__init__()

    def initialize(self,uri,protocols = None,origin = None,key = None,debug = None):
        if (key is None):
            key = "wskey"
        if (debug is None):
            debug = True
        _gthis = self
        if (origin is None):
            origin = "http://127.0.0.1/"
        self.protocols = protocols
        self.origin = origin
        self.key = key
        self.debug = debug
        reg = EReg("^(\\w+?)://([\\w\\.-]+)(:(\\d+))?(/.*)?$","")
        reg.matchObj = python_lib_Re.search(reg.pattern,uri)
        if (reg.matchObj is None):
            raise haxe_Exception.thrown((("Uri not matching websocket uri \"" + ("null" if uri is None else uri)) + "\""))
        self.scheme = reg.matchObj.group(1)
        _g = self.scheme
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 3):
            if (_g == "wss"):
                self.secure = True
            else:
                raise haxe_Exception.thrown((("Scheme \"" + HxOverrides.stringOrNull(self.scheme)) + "\" is not a valid websocket scheme"))
        elif (_hx_local_0 == 2):
            if (_g == "ws"):
                self.secure = False
            else:
                raise haxe_Exception.thrown((("Scheme \"" + HxOverrides.stringOrNull(self.scheme)) + "\" is not a valid websocket scheme"))
        else:
            raise haxe_Exception.thrown((("Scheme \"" + HxOverrides.stringOrNull(self.scheme)) + "\" is not a valid websocket scheme"))
        self.host = reg.matchObj.group(2)
        self.port = (Std.parseInt(reg.matchObj.group(4)) if ((reg.matchObj.group(4) is not None)) else (443 if (self.secure) else 80))
        self.path = reg.matchObj.group(5)
        if (self.path is None):
            self.path = "/"
        self.socket = haxe_net_Socket2.create(self.host,self.port,self.secure,debug)
        self.state = haxe_net_impl_State.Handshake
        def _hx_local_1():
            _gthis._debug("socket connected",_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 46, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "initialize"}))
            _gthis.writeBytes(_gthis.prepareClientHandshake(_gthis.path,_gthis.host,_gthis.port,key,origin))
        self.socket.onconnect = _hx_local_1
        self.commonInitialize()
        return self

    def commonInitialize(self):
        _gthis = self
        self.socketData = haxe_net_impl_BytesRW()
        def _hx_local_0():
            _gthis._debug("socket closed",_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 58, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "commonInitialize"}))
            _gthis.setClosed()
        self.socket.onclose = _hx_local_0
        def _hx_local_1():
            _gthis._debug("ioerror: ",_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 62, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "commonInitialize"}))
            _gthis.onerror("error")
        self.socket.onerror = _hx_local_1
        def _hx_local_2(data):
            _gthis.socketData.writeBytes(data)
            _gthis.handleData()
        self.socket.ondata = _hx_local_2

    def process(self):
        self.socket.process()
        if self.needHandleData:
            self.handleData()

    def _debug(self,msg,p = None):
        if (not self.debug):
            return
        haxe_Log.trace(msg,p)

    def writeBytes(self,data):
        try:
            self.socket.send(data)
        except BaseException as _g:
            None
            e = haxe_Exception.caught(_g).unwrap()
            haxe_Log.trace(e,_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 103, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "writeBytes"}))
            self.onerror(Std.string(e))

    def handleData(self):
        self.needHandleData = False
        while True:
            if (self.payload is None):
                self.payload = haxe_net_impl_BytesRW()
            tmp = self.state.index
            if (tmp == 0):
                if (not self.readHttpHeader()):
                    return
                self.state = haxe_net_impl_State.Head
                self.onopen()
            elif (tmp == 1):
                if (not self.readHttpHeader()):
                    return
                try:
                    handshake = self.prepareServerHandshake()
                    self._debug(("Sending responce: " + ("null" if handshake is None else handshake)),_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 140, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "handleData"}))
                    self.writeBytes(haxe_io_Bytes.ofString(handshake))
                    self.state = haxe_net_impl_State.Head
                    self.onopen()
                except BaseException as _g:
                    None
                    _g1 = haxe_Exception.caught(_g).unwrap()
                    if Std.isOfType(_g1,str):
                        e = _g1
                        self.writeBytes(haxe_io_Bytes.ofString(self.prepareHttp400(e)))
                        self._debug(("Error in http request: " + ("null" if e is None else e)),_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 147, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "handleData"}))
                        self.socket.close()
                        self.state = haxe_net_impl_State.Closed
                    else:
                        raise _g
            elif (tmp == 2):
                if (self.socketData.available < 2):
                    return
                b0 = self.socketData.readByte()
                b1 = self.socketData.readByte()
                self.isFinal = ((((b0 >> 7) & 1)) != 0)
                def _hx_local_1():
                    _hx_local_0 = (b0 & 15)
                    if (Std.isOfType(_hx_local_0,Int) or ((_hx_local_0 is None))):
                        _hx_local_0
                    else:
                        raise "Class cast error"
                    return _hx_local_0
                self.opcode = _hx_local_1()
                self.frameIsBinary = (False if ((self.opcode == 1)) else (True if ((self.opcode == 2)) else self.frameIsBinary))
                self.partialLength = (b1 & 127)
                self.isMasked = ((((b1 >> 7) & 1)) != 0)
                self.state = haxe_net_impl_State.HeadExtraLength
            elif (tmp == 3):
                if (self.partialLength == 126):
                    if (self.socketData.available < 2):
                        return
                    self.length = self.socketData.readUnsignedShort()
                elif (self.partialLength == 127):
                    if (self.socketData.available < 8):
                        return
                    tmp1 = self.socketData.readUnsignedInt()
                    if (tmp1 != 0):
                        raise haxe_Exception.thrown("message too long")
                    self.length = self.socketData.readUnsignedInt()
                else:
                    self.length = self.partialLength
                self.state = haxe_net_impl_State.HeadExtraMask
            elif (tmp == 4):
                if self.isMasked:
                    if (self.socketData.available < 4):
                        return
                    self.mask = self.socketData.readBytes(4)
                self.state = haxe_net_impl_State.Body
            elif (tmp == 5):
                if (self.socketData.available < self.length):
                    return
                self.payload.writeBytes(self.socketData.readBytes(self.length))
                _g2 = self.opcode
                if (((_g2 == 2) or ((_g2 == 1))) or ((_g2 == 0))):
                    self._debug((("Received message, " + "Type: ") + Std.string(self.opcode)),_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 189, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "handleData"}))
                    if self.isFinal:
                        messageData = self.payload.readAllAvailableBytes()
                        unmakedMessageData = (haxe_net_impl_WebSocketGeneric.applyMask(messageData,self.mask) if (self.isMasked) else messageData)
                        if self.frameIsBinary:
                            self.onmessageBytes(unmakedMessageData)
                        else:
                            self.onmessageString(haxe_net_impl_Utf8Encoder.decode(unmakedMessageData))
                        self.payload = None
                elif (_g2 == 8):
                    self._debug("Socket Closed",_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 209, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "handleData"}))
                    self.setClosed()
                    try:
                        self.socket.close()
                    except BaseException as _g3:
                        None
                elif (_g2 == 9):
                    self._debug("Received Ping",_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 201, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "handleData"}))
                    self.sendFrame(self.payload.readAllAvailableBytes(),10)
                elif (_g2 == 10):
                    self._debug("Received Pong",_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 205, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "handleData"}))
                    self.lastPong = Date.now()
                else:
                    pass
                if (self.state != haxe_net_impl_State.Closed):
                    self.state = haxe_net_impl_State.Head
            else:
                return

    def setClosed(self):
        if (self.state != haxe_net_impl_State.Closed):
            self.state = haxe_net_impl_State.Closed
            self.onclose()

    def ping(self):
        self.sendFrame(haxe_io_Bytes.alloc(0),9)

    def isHttpHeaderRead(self):
        return (HxString.substr(self.httpHeader,-4,None) == "\r\n\r\n")

    def readHttpHeader(self):
        while ((not self.isHttpHeaderRead()) and ((self.socketData.available > 0))):
            tmp = self
            tmp1 = tmp.httpHeader
            code = self.socketData.readByte()
            tmp.httpHeader = (("null" if tmp1 is None else tmp1) + HxOverrides.stringOrNull("".join(map(chr,[code]))))
        return self.isHttpHeaderRead()

    def prepareServerHandshake(self):
        if self.debug:
            haxe_Log.trace(("HTTP request: \n" + HxOverrides.stringOrNull(self.httpHeader)),_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 246, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "prepareServerHandshake"}))
        _this = self.httpHeader
        requestLines = _this.split("\r\n")
        if (len(requestLines) != 0):
            requestLines.pop()
        if (len(requestLines) != 0):
            requestLines.pop()
        firstLine = (None if ((len(requestLines) == 0)) else requestLines.pop(0))
        regexp = EReg("^GET (.*) HTTP/1.1$","")
        regexp.matchObj = python_lib_Re.search(regexp.pattern,firstLine)
        if (regexp.matchObj is None):
            raise haxe_Exception.thrown((("First line of HTTP request is invalid: \"" + ("null" if firstLine is None else firstLine)) + "\""))
        self.path = regexp.matchObj.group(1)
        key = None
        version = None
        upgrade = None
        connection = None
        regexp = EReg("^(.*): (.*)$","")
        _g = 0
        while (_g < len(requestLines)):
            header = (requestLines[_g] if _g >= 0 and _g < len(requestLines) else None)
            _g = (_g + 1)
            regexp.matchObj = python_lib_Re.search(regexp.pattern,header)
            if (regexp.matchObj is None):
                raise haxe_Exception.thrown((("HTTP request line is invalid: \"" + ("null" if header is None else header)) + "\""))
            name = regexp.matchObj.group(1)
            value = regexp.matchObj.group(2)
            name1 = name
            _hx_local_1 = len(name1)
            if (_hx_local_1 == 17):
                if (name1 == "Sec-WebSocket-Key"):
                    key = value
            elif (_hx_local_1 == 10):
                if (name1 == "Connection"):
                    connection = value
            elif (_hx_local_1 == 7):
                if (name1 == "Upgrade"):
                    upgrade = value
            elif (_hx_local_1 == 21):
                if (name1 == "Sec-WebSocket-Version"):
                    version = value
            else:
                pass
        tmp = None
        if (not (((version != "13") or ((upgrade != "websocket"))))):
            startIndex = None
            tmp = (((connection.find("Upgrade") if ((startIndex is None)) else HxString.indexOfImpl(connection,"Upgrade",startIndex))) < 0)
        else:
            tmp = True
        if (tmp or ((key is None))):
            raise haxe_Exception.thrown("\n".join([python_Boot.toString1(x1,'') for x1 in [(("\"Sec-WebSocket-Version\" is \"" + ("null" if version is None else version)) + "\", should be 13"), (("\"upgrade\" is \"" + ("null" if upgrade is None else upgrade)) + "\", should be \"websocket\""), (("\"Sec-WebSocket-Key\" is \"" + ("null" if key is None else key)) + "\", should be present")]]))
        acceptKey = haxe_crypto_Base64.encode(haxe_crypto_Sha1.make(haxe_io_Bytes.ofString((("null" if key is None else key) + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"))))
        if self.debug:
            haxe_Log.trace("Websocket succefully connected",_hx_AnonObject({'fileName': "haxe/net/impl/WebSocketGeneric.hx", 'lineNumber': 292, 'className': "haxe.net.impl.WebSocketGeneric", 'methodName': "prepareServerHandshake"}))
        return "\r\n".join([python_Boot.toString1(x1,'') for x1 in ["HTTP/1.1 101 Switching Protocols", "Upgrade: websocket", "Connection: Upgrade", ("Sec-WebSocket-Accept: " + ("null" if acceptKey is None else acceptKey)), "", ""]])

    def prepareHttp400(self,message):
        return "\r\n".join([python_Boot.toString1(x1,'') for x1 in ["HTTP/1.1 400 Bad request", "", "<h1>HTTP 400 Bad request</h1>", message]])

    def prepareClientHandshake(self,url,host,port,key,origin):
        lines = []
        lines.append((("GET " + ("null" if url is None else url)) + " HTTP/1.1"))
        lines.append(((("Host: " + ("null" if host is None else host)) + ":") + Std.string(port)))
        lines.append("Pragma: no-cache")
        lines.append("Cache-Control: no-cache")
        lines.append("Upgrade: websocket")
        if (self.protocols is not None):
            _this = self.protocols
            x = ("Sec-WebSocket-Protocol: " + HxOverrides.stringOrNull(", ".join([python_Boot.toString1(x1,'') for x1 in _this])))
            lines.append(x)
        lines.append("Sec-WebSocket-Version: 13")
        lines.append("Connection: Upgrade")
        x = ("Sec-WebSocket-Key: " + HxOverrides.stringOrNull(haxe_crypto_Base64.encode(haxe_net_impl_Utf8Encoder.encode(key))))
        lines.append(x)
        lines.append(("Origin: " + ("null" if origin is None else origin)))
        lines.append("User-Agent: Mozilla/5.0")
        return haxe_net_impl_Utf8Encoder.encode((HxOverrides.stringOrNull("\r\n".join([python_Boot.toString1(x1,'') for x1 in lines])) + "\r\n\r\n"))

    def close(self):
        if (self.state != haxe_net_impl_State.Closed):
            self.sendFrame(haxe_io_Bytes.alloc(0),8)
            self.socket.close()
            self.setClosed()

    def sendFrame(self,data,_hx_type):
        self.writeBytes(self.prepareFrame(data,_hx_type,True))

    def get_readyState(self):
        tmp = self.state.index
        if (tmp == 0):
            return haxe_net_ReadyState.Connecting
        elif (tmp == 1):
            return haxe_net_ReadyState.Connecting
        elif (tmp == 2):
            return haxe_net_ReadyState.Open
        elif (tmp == 3):
            return haxe_net_ReadyState.Open
        elif (tmp == 4):
            return haxe_net_ReadyState.Open
        elif (tmp == 5):
            return haxe_net_ReadyState.Open
        elif (tmp == 6):
            return haxe_net_ReadyState.Closed
        else:
            pass

    def sendString(self,message):
        if (self.get_readyState() != haxe_net_ReadyState.Open):
            raise haxe_Exception.thrown("websocket not open")
        self.sendFrame(haxe_net_impl_Utf8Encoder.encode(message),1)

    def sendBytes(self,message):
        if (self.get_readyState() != haxe_net_ReadyState.Open):
            raise haxe_Exception.thrown("websocket not open")
        self.sendFrame(message,2)

    def prepareFrame(self,data,_hx_type,isFinal):
        out = haxe_net_impl_BytesRW()
        isMasked = True
        mask = haxe_net_impl_WebSocketGeneric.generateMask()
        sizeMask = (128 if isMasked else 0)
        out.writeByte((haxe_net_impl__WebSocketGeneric_Opcode_Impl_.toInt(_hx_type) | ((128 if isFinal else 0))))
        if (data.length < 126):
            out.writeByte((data.length | sizeMask))
        elif (data.length < 65536):
            out.writeByte((126 | sizeMask))
            out.writeShort(data.length)
        else:
            out.writeByte((127 | sizeMask))
            out.writeInt(0)
            out.writeInt(data.length)
        if isMasked:
            out.writeBytes(mask)
        out.writeBytes((haxe_net_impl_WebSocketGeneric.applyMask(data,mask) if isMasked else data))
        return out.readAllAvailableBytes()

    @staticmethod
    def create(uri,protocols = None,origin = None,key = None,debug = None):
        if (key is None):
            key = "wskey"
        return haxe_net_impl_WebSocketGeneric().initialize(uri,protocols,origin,key,debug)

    @staticmethod
    def createFromAcceptedSocket(socket,alreadyRecieved = None,debug = None):
        if (alreadyRecieved is None):
            alreadyRecieved = ""
        websocket = haxe_net_impl_WebSocketGeneric()
        websocket.socket = socket
        websocket.debug = debug
        websocket.commonInitialize()
        websocket.state = haxe_net_impl_State.ServerHandshake
        websocket.httpHeader = alreadyRecieved
        websocket.needHandleData = True
        return websocket

    @staticmethod
    def generateMask():
        maskData = haxe_io_Bytes.alloc(4)
        v = int((python_lib_Random.random() * 256))
        maskData.b[0] = (v & 255)
        v = int((python_lib_Random.random() * 256))
        maskData.b[1] = (v & 255)
        v = int((python_lib_Random.random() * 256))
        maskData.b[2] = (v & 255)
        v = int((python_lib_Random.random() * 256))
        maskData.b[3] = (v & 255)
        return maskData

    @staticmethod
    def applyMask(payload,mask):
        maskedPayload = haxe_io_Bytes.alloc(payload.length)
        _g = 0
        _g1 = payload.length
        while (_g < _g1):
            n = _g
            _g = (_g + 1)
            v = (payload.b[n] ^ mask.b[HxOverrides.mod(n, mask.length)])
            maskedPayload.b[n] = (v & 255)
        return maskedPayload


class haxe_net_impl_State(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.net.impl.State"
    _hx_constructs = ["Handshake", "ServerHandshake", "Head", "HeadExtraLength", "HeadExtraMask", "Body", "Closed"]
haxe_net_impl_State.Handshake = haxe_net_impl_State("Handshake", 0, ())
haxe_net_impl_State.ServerHandshake = haxe_net_impl_State("ServerHandshake", 1, ())
haxe_net_impl_State.Head = haxe_net_impl_State("Head", 2, ())
haxe_net_impl_State.HeadExtraLength = haxe_net_impl_State("HeadExtraLength", 3, ())
haxe_net_impl_State.HeadExtraMask = haxe_net_impl_State("HeadExtraMask", 4, ())
haxe_net_impl_State.Body = haxe_net_impl_State("Body", 5, ())
haxe_net_impl_State.Closed = haxe_net_impl_State("Closed", 6, ())


class haxe_net_impl__WebSocketGeneric_Opcode_Impl_:
    _hx_class_name = "haxe.net.impl._WebSocketGeneric.Opcode_Impl_"
    __slots__ = ()
    _hx_statics = ["Continuation", "Text", "Binary", "Close", "Ping", "Pong", "toInt"]

    @staticmethod
    def toInt(this1):
        return this1


class haxe_net_impl_Utf8Encoder:
    _hx_class_name = "haxe.net.impl.Utf8Encoder"
    __slots__ = ()
    _hx_statics = ["encode", "decode"]

    @staticmethod
    def encode(_hx_str):
        return haxe_io_Bytes.ofString(_hx_str)

    @staticmethod
    def decode(data):
        return data.toString()


class python_Boot:
    _hx_class_name = "python.Boot"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except BaseException as _g:
                None
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except BaseException as _g:
            None
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except BaseException as _g:
                    None
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o1 = o
                l = len(o1.params)
                hasParams = (l > 0)
                if hasParams:
                    paramsStr = ""
                    _g = 0
                    _g1 = l
                    while (_g < _g1):
                        i = _g
                        _g = (_g + 1)
                        prefix = ""
                        if (i > 0):
                            prefix = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1(o1.params[i],s))))))
                    return (((HxOverrides.stringOrNull(o1.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o1.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields = python_Boot.getInstanceFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
                else:
                    fields = python_Boot.getClassFields(o)
                    _g = []
                    _g1 = 0
                    while (_g1 < len(fields)):
                        f = (fields[_g1] if _g1 >= 0 and _g1 < len(fields) else None)
                        _g1 = (_g1 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g.append(x)
                    fieldsStr = _g
                    toStr = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " )")
                    return toStr
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except BaseException as _g:
                None
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d = o.__dict__
                keys1 = d.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        elif isinstance(o,list):
            field1 = field
            _hx_local_1 = len(field1)
            if (_hx_local_1 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 4):
                if (field1 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field1 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field1 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field1 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 5):
                if (field1 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field1 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field1 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field1 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 3):
                if (field1 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field1 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 8):
                if (field1 == "contains"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.contains)
                elif (field1 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field1 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 16):
                if (field1 == "keyValueIterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.keyValueIterator)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            elif (_hx_local_1 == 6):
                if (field1 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field1 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field1 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field1 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    if hasattr(o,field1):
                        return getattr(o,field1)
                    else:
                        return None
            else:
                field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                if hasattr(o,field1):
                    return getattr(o,field1)
                else:
                    return None
        else:
            field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            if hasattr(o,field1):
                return getattr(o,field1)
            else:
                return None

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except BaseException as _g:
            None
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1


class python_Lib:
    _hx_class_name = "python.Lib"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "keyValueIterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "contains", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def keyValueIterator(x):
        return haxe_iterators_ArrayKeyValueIterator(x)

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except BaseException as _g:
            None
            return False

    @staticmethod
    def contains(x,e):
        return (e in x)

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class HxOverrides:
    _hx_class_name = "HxOverrides"
    __slots__ = ()
    _hx_statics = ["eq", "stringOrNull", "rshift", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def rshift(val,n):
        return ((val % 0x100000000) >> n)

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString:
    _hx_class_name = "HxString"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "indexOfImpl", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        elif (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return HxString.indexOfImpl(s,_hx_str,startIndex)

    @staticmethod
    def indexOfImpl(s,_hx_str,startIndex):
        if (_hx_str == ""):
            length = len(s)
            if (startIndex < 0):
                startIndex = (length + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            if (startIndex > length):
                return length
            else:
                return startIndex
        return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


class sys_net_Host:
    _hx_class_name = "sys.net.Host"
    __slots__ = ("host", "name")
    _hx_fields = ["host", "name"]
    _hx_methods = ["toString"]

    def __init__(self,name):
        self.host = name
        self.name = name

    def toString(self):
        return self.name



class sys_net__Socket_SocketInput(haxe_io_Input):
    _hx_class_name = "sys.net._Socket.SocketInput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["readByte", "readBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self._hx___s = s

    def readByte(self):
        r = None
        try:
            r = self._hx___s.recv(1,0)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g
        if (len(r) == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        return r[0]

    def readBytes(self,buf,pos,_hx_len):
        r = None
        data = buf.b
        try:
            r = self._hx___s.recv(_hx_len,0)
            _g = pos
            _g1 = (pos + len(r))
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                data.__setitem__(i,r[(i - pos)])
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g
        if (len(r) == 0):
            raise haxe_Exception.thrown(haxe_io_Eof())
        return len(r)



class sys_net__Socket_SocketOutput(haxe_io_Output):
    _hx_class_name = "sys.net._Socket.SocketOutput"
    __slots__ = ("_hx___s",)
    _hx_fields = ["__s"]
    _hx_methods = ["writeByte", "writeBytes"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,s):
        self._hx___s = s

    def writeByte(self,c):
        try:
            self._hx___s.send(bytes([c]),0)
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g

    def writeBytes(self,buf,pos,_hx_len):
        try:
            data = buf.b
            payload = data[pos:pos+_hx_len]
            r = self._hx___s.send(payload,0)
            return r
        except BaseException as _g:
            None
            if Std.isOfType(haxe_Exception.caught(_g).unwrap(),BlockingIOError):
                raise haxe_Exception.thrown(haxe_io_Error.Blocked)
            else:
                raise _g



class sys_net_Socket:
    _hx_class_name = "sys.net.Socket"
    __slots__ = ("_hx___s", "input", "output")
    _hx_fields = ["__s", "input", "output"]
    _hx_methods = ["__initSocket", "close", "connect", "listen", "bind", "accept", "host", "setBlocking", "fileno"]
    _hx_statics = ["select"]

    def __init__(self):
        self.output = None
        self.input = None
        self._hx___s = None
        self._hx___initSocket()
        self.input = sys_net__Socket_SocketInput(self._hx___s)
        self.output = sys_net__Socket_SocketOutput(self._hx___s)

    def _hx___initSocket(self):
        self._hx___s = python_lib_socket_Socket()

    def close(self):
        self._hx___s.close()

    def connect(self,host,port):
        host_str = host.toString()
        self._hx___s.connect((host_str, port))

    def listen(self,connections):
        self._hx___s.listen(connections)

    def bind(self,host,port):
        host_str = host.toString()
        self._hx___s.bind((host_str, port))

    def accept(self):
        tp2 = self._hx___s.accept()
        s = sys_net_Socket()
        s._hx___s = tp2[0]
        s.input = sys_net__Socket_SocketInput(s._hx___s)
        s.output = sys_net__Socket_SocketOutput(s._hx___s)
        return s

    def host(self):
        pn = self._hx___s.getsockname()
        return _hx_AnonObject({'host': sys_net_Host(pn[0]), 'port': pn[1]})

    def setBlocking(self,b):
        self._hx___s.setblocking(b)

    def fileno(self):
        return self._hx___s.fileno()

    @staticmethod
    def select(read,write,others,timeout = None):
        t3 = python_lib_Select.select(read,write,others,timeout)
        return _hx_AnonObject({'read': t3[0], 'write': t3[1], 'others': t3[2]})


Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

WebSocketHandler._nextId = 0
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS)
haxe_net_impl__WebSocketGeneric_Opcode_Impl_.Continuation = 0
haxe_net_impl__WebSocketGeneric_Opcode_Impl_.Text = 1
haxe_net_impl__WebSocketGeneric_Opcode_Impl_.Binary = 2
haxe_net_impl__WebSocketGeneric_Opcode_Impl_.Close = 8
haxe_net_impl__WebSocketGeneric_Opcode_Impl_.Ping = 9
haxe_net_impl__WebSocketGeneric_Opcode_Impl_.Pong = 10
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")

WebSocketServerExample.main()
